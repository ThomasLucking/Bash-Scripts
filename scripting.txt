

#!/bin/bash
echo "Today is " `date`

echo -e "\nenter the path to directory"
read the_path

echo -e "\n you path has the following files and folders: "
ls $the_path

Line #1: The shebang (#!/bin/bash) points toward the bash shell path.
Line #2: The echo command is displaying the current date and time on the terminal. Note that the date is in backticks.
Line #4: We want the user to enter a valid path.
Line #5: The read command reads the input and stores it in the variable the_path.
line #8: The ls command takes the variable with the stored path and displays the current files and folders.

this is for the run_all.sh bash script explaining each line


chmod modifies the permission and ownership of a file for the current user (u) +x adds the execution rights to the current user this means that the user who is the owner can now run the script 

run_all.sh is the file I wanna run


the path varibale is already predefinied this script basically prints out the contents of the current directoy you're currently in when you run it, and also it shows the current date


for bash you need to define varirables for read for example if you say "read path_name" path_name is then automatically declared as a varaible.


Basic Bash commands (echo, read, etc.)
Here is a list of some of the most commonly used bash commands:

cd: Change the directory to a different location.
ls: List the contents of the current directory.
mkdir: Create a new directory.
touch: Create a new file.
rm: Remove a file or directory.
cp: Copy a file or directory.
mv: Move or rename a file or directory.
echo: Print text to the terminal.
cat: Concatenate and print the contents of a file.
grep: Search for a pattern in a file.
chmod: Change the permissions of a file or directory.
sudo: Run a command with administrative privileges.
df: Display the amount of disk space available.
history: Show a list of previously executed commands.
ps: Display information about running processes.


cron states are like basically when a program automatically executes.

00 - midnight everyday
/5 runs a script every 5 minutes

0 6 1-5 runs a script at 6am from monday to friday

0 0 1-7 runs a script for the first 7 days of the month

0 12 1  runs the script on the first day of every month


/5 = 5 minutes

00 = midnight

0 6 1-5

set -x this basically is for debugging and it shows you what each line of bash like runs it can be really easy to find bugs this way.
set -e this basically exits the code when the program is wrong.

the difference between chmod 755 and chmod u+x is basically chmod 755 modifies other permission and chmod u+x just modifies the owner perms and executable




#!/bin/bash

search_function() {
    echo "Enter username to search:"
    read username
    grep -i "$username" data.txt || echo "Not found."
}

add_function() {
    echo "Please add your username."
    read username_add
    echo "Please add your telephone number."
    read telephone_add
    echo "please add your email."
    read email_add
    # echo "$username_add" "$telephone_add" "$email_add" >> data.txt
    {
        echo "Name: [ $username_add ]"
        echo "Phone number: [ $telephone_add ]"
        echo "Email: [ $email_add ]"
    } >> data.txt # the extra {} allows you to write multiple things in a file.
    echo "Added username: $username_add"
    echo "Added phone number: " $telephone_add
    echo "Added email: " $email_add 
}
#!/bin/bash

search_function() {
    echo "Enter username to search:"
    read username
    grep -i "$username" data.txt || echo "Not found."
}

add_function() {
    echo "Please add your username."
    read username_add
    echo "Please add your telephone number."
    read telephone_add
    echo "please add your email."
    read email_add
    # echo "$username_add" "$telephone_add" "$email_add" >> data.txt
    {
remove_edit_function() {
    echo "everything inside data.txt"   
    
    # Custom counter implementation instead of nl
    person_counter=1
    line_counter=1
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Check which field this line represents based on line position
        field_position=$(((line_counter - 1) % 3 + 1))
        
        case $fi#!/bin/bash

search_function() {
    echo "Enter username to search:"
    read username
    grep -i "$username" data.txt || echo "Not found."
}

add_function() {
    echo "Please add your username."
    read username_add
    echo "Please add your telephone number."
    read telephone_add
    echo "please add your email."
    read email_add
    # echo "$username_add" "$telephone_add" "$email_add" >> data.txt
    {eld_position in
            1) echo "Person $person_counter - $line" ;;
            2) echo "Person $person_counter - $line" ;;
            3) echo "Person $person_counter - $line"
               ((person_counter++)) ;; # Increment person counter after email (3rd line)
        esac
        
        ((line_counter++))
    done < data.txt
    
    total_lines=$(wc -l < data.txt) # this calculates how many lines are there
    num_people=$((total_lines / 3)) # then divides them by 3 

    echo "there are $num_people people in the database" # this tells you how many people are in the database based on math 
    read -p "Which person do you want to edit (1-$num_people): " person_num # asks which person you want to modify

    if [[ $person_num -lt 1 || $person_num -gt $num_people ]]; then # this checks if the user inputed a correct user number.
        echo "Invalid person number."
        return
    fi
    
    
    echo "Which field would you like to modify (name/phone/email):" # this asks the user which field they would like to modify
    read field  # reads the value of the input.
    
    #  this calculates  which line number to change based on person and field
    case $field in 
        name) line_number=$((( person_num - 1) * 3 + 1)) ;;
        phone) line_number=$((( person_num - 1) * 3 + 2)) ;;
        email) line_number=$((( person_num - 1) * 3 + 3)) ;; # The formula calculates the line by counting all lines in previous 3-line person blocks and then adding the field's position within the current person's block.
        *) echo "invalid field."; return ;;
    esac

    read -p "Enter the new value for $field: " new_value # this asks the new value for that specific line.
    
    tmpfile=$(mktemp) # this line creates a temporary file to avoid confusion and replacing contents over each other.
    counter=0 # this basically makes sure which line we are reading from the data.txt file

    # Read file line by line and only modify the target line
    while IFS= read -r line || [ -n "$line" ]; do # this reads the file line by line IFS prevents leading or trailing whitespaces -r prevents interpreting backslashes as escape character. and the -n $line prevents the read even if it doesn't end with a newline character
        ((counter++)) # increments the counter by 1 to keep track of the current line
        # this checks if this is the line we want to modify
        if [[ $counter -eq $line_number ]]; then
            if [[ $field == "name" ]]; then
                echo "Name: [ $new_value ]" >> "$tmpfile"
            elif [[ $field == "phone" ]]; then
                echo "Phone number: [ $new_value ]" >> "$tmpfile"
            elif [[ $field == "email" ]]; then
                echo "Email: [ $new_value ]" >> "$tmpfile"
            fi
        else
            # Keep the original line unchanged
            echo "$line" >> "$tmpfile"
        fi
    done < data.txt # reads from the data.txt

    mv "$tmpfile" data.txt # moves everything from the temporary file to data.txt 
    echo "Modification successful." # success
}

while true; do
    echo "1) Search"
    echo "2) Add"
    echo "3) Remove/Edit"
    echo "4) Exit"
    read -p "Choose an option: " choice

    case $choice in
        1) search_function ;;
        2) add_function ;;
        3) remove_edit_function ;;
        4) break ;;
        *) echo "Invalid option" ;;
    esac
done